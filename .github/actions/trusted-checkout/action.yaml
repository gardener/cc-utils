name: Trusted Checkout
description: |
  A wrapper around github.com/actions/checkout, with safety measures for pullrequests triggered
  from forks with `pull_request_target` event.

  It will by default behave identical to wrapped checkout-action. For pullrequests from forked
  repositories, which are triggered by the `pull_request_target` event (where wrapped checkout
  action will by default checkout receiving repository's contents), this action will instead
  checkout the pullrequest's contents (to allow for building/testing code proposed by the
  pullrequest). As this is generally considered to be unsafe, this will only be done under certain
  conditions:

  - if the fork's owner is equal to the target's (i.e. fork within the same organisation)
  - if the author_association is one of:
    - COLLABORATOR
    - MEMBER
    - OWNER

inputs:
  fetch-depth:
    type: number
    default: 1
    required: false
    description: |
      passed to `actions/checkout` as `fetch-depth` input.

      useful for cases where longer history is required.
  submodules:
    type: string
    default: false
    description: |
      passed to `actions/checkout` as `submodules` input.
  token:
    type: string
    default: ''
    description: |
      passed to `actions/checkout` as `token` input.
  trusted-label:
    type: string
    default: 'reviewed/ok-to-test'
    description: |
      a label, that can be used to mark pullrequests as trusted, regardless of author's association.

      For security-reasons, this action will remove the label, such that it will have to be
      added again (adding the label will work as trigger).
  needs-trusted-label:
    type: string
    default: 'needs/ok-to-test'
    description: |
      a label that is added as a marker in order to notify lack of "trusted-label"
  remove-trusted-label:
    type: boolean
    default: true
    description: |
      if set to false, will not attempt to remove "trusted-label". Use to run from workflows
      that do not have `pull-requests: write` permission. Be sure to run w/ this input
      set to true (the default) in an early run.
  path:
    type: string
    description: |
      passed as `path` input to checkout-action (relative path to checkout into)

runs:
  using: composite
  steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: ${{ inputs.fetch-depth }}
        path: ${{ inputs.path }}
        submodules: ${{ inputs.submodules }}
        token: ${{ inputs.token }}
    - name: checkout-pullrequest
      if: ${{ github.event_name == 'pull_request_target' }}
      id: calc
      shell: python
      run: |
        import os
        import subprocess
        import textwrap

        allowed_author_associations = (
          'COLLABORATOR',
          'MEMBER',
          'OWNER',
        )
        author_association = '${{ github.event.pull_request.author_association }}'
        allowed_to_checkout = author_association in allowed_author_associations

        # if pullrequest is labelled, it is also considered trusted, regardless of
        # author's association (rationale: only codeowners can add labels)
        trusted_label = '${{ inputs.trusted-label }}'

        if '${{ github.event.action }}' == 'labeled':
          if '${{ github.event.label.name }}' == trusted_label:
            allowed_to_checkout = True
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'remove-label={trusted_label}\n')

        if not allowed_to_checkout:
          summary = textwrap.dedent(f'''\
          > [!WARNING]
          > Checked out target-repository's contents, as pullrequest author is not trusted
          ''')
          with open(os.environ['GITHUB_STEP_SUMMARY'], 'a') as f:
            f.write(summary)
          exit(0)

        # allowed to checkout
        repository = '${{ github.event.pull_request.head.repo.full_name }}'
        remote = f'${{ github.server_url }}/{repository}'
        summary = ''

        repo_path = '${{ inputs.path }}'
        if repo_path == '.':
          repo_path = ''

        subprocess.run(
          (
            'git',
            '-C',  repo_path,
            'fetch', remote, 'refs/heads/${{ github.head_ref }}',
          ),
          check=True,
        )

        output = subprocess.run(
          (
            'git',
            '-C',  repo_path,
            'rev-parse', 'FETCH_HEAD',
          ),
          check=True,
          capture_output=True,
          encoding='utf-8',
        )

        fetched_head_digest = output.stdout.strip()
        checkout_ref = '${{ github.event.pull_request.head.sha }}'
        if checkout_ref != fetched_head_digest:
          print('WARNING: pullrequest seems to have been modified')
          print(f'{fetched_head_digest=} vs {checkout_ref=}')

          summary = textwrap.dedent(f'''\
          > [!WARNING]
          > The pullrequest was modified after pipeline was triggered:
          > initial: {checkout_ref}
          > after change: {fetched_head_digest}
          >
          > The pipeline will run based on `initial` commit
          ''')
          with open(os.environ['GITHUB_STEP_SUMMARY'], 'a') as f:
            f.write(summary)
          exit(0)

        subprocess.run(
          (
            'git',
            '-C',  repo_path,
            'checkout', '-B', '${{ github.head_ref }}', checkout_ref,
          ),
          check=True,
        )
    - if: ${{ steps.calc.outputs.remove-label }}
      uses: gardener/cc-utils/.github/actions/install-gardener-gha-libs@master
    - name: remove-trusted-and-add-needs-label
      if: ${{ steps.calc.outputs.remove-label != '' && inputs.remove-trusted-label == 'true' }}
      shell: python
      run: |
        import github3.exceptions
        import github
        gh_api = github.github_api(token='${{ github.token }}')
        _, org, repo = github.host_org_and_repo()
        gh_repo = gh_api.repository(org, repo)

        # we need issue-api to rm label (id is equal for pr and issue)
        pull_request = gh_repo.issue(${{ github.event.number }})

        label_to_rm = '${{ steps.calc.outputs.remove-label }}'
        for label in pull_request.labels():
          if label.name == label_to_rm:
            break
        else:
          # label not present - hence do not need to attempt removal
          exit(0)

        try:
          pull_request.remove_label(label_to_rm)
        except github3.exceptions.NotFoundError:
          # trusted-checkout typically runs multiple times, so the label already being absent
          # is an expected, and of course, acceptable case
          exit(0)

        pull_request.add_labels('${{ inputs.needs-trusted-label }}')
